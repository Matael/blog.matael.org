<!DOCTYPE html>
<html lang="en">
	<head>
			<title>Thinking at Random</title>
		<meta charset="utf-8" />


		<meta name="tags" content="arduino" />
		<meta name="tags" content="dmx" />
		<meta name="tags" content="imported" />

		<link rel=stylesheet/less type=text/css media=screen href="/theme/css/style.css" />
		<link rel=stylesheet type=text/css media=screen href="/theme/css/pygment.css" />
		<script src="/theme/js/less.min.js"></script>
	</head>

	<body>
		<div id=logo><div id=logo-wrapper>
			<header>
				<h1><a href="/"<span class=overbar><span class=big>t</span>hinking <span class=accent>at</span> <span class=big>r</span>andom</span></a></h1>
			</header>
			<nav>
				<ul>
					<li><a href="/">Writing</a></li>
					<li><a href="https://github.com/Matael">Github</a></li>
					<li><a href="https://matael.org">About</a></li>
				</ul>
			</nav>
		</div></div>
		<div id=page>
<section id=content>
	<header>
		<h1>Arduino et DMX</h1>
		
	</header>
	<article>

	<div id=meta>
		<p class=by-line>Published by 
				<a href="/author/matael.html" class=author>matael</a>
		</p>
		<p>On <time datetime="2015-01-04T11:28:39+01:00">Sun 04 January 2015</span></p>
		<ul class=tags>
				<li><a href="/tag/arduino.html">arduino</a></li>
				<li><a href="/tag/dmx.html">dmx</a></li>
				<li><a href="/tag/imported.html">imported</a></li>
		</ul>
	</div>
	<div id=article_body>
		<p>Entrant dans un nouvel appartement, je me suis dit que créer une ambiance sympa avec de la lumière pouvait être une
bonne idée.</p>
<p>L'opportunité s'est présentée quand j'ai pu m'acheter un PAR 56 Led. Comme la majorité des projecteur de ce type, le PAR
Led est muni d'un récepteur DMX et peut donc être assigné directement.</p>
<p>L'avant dernière étape était de pouvoir contrôler la bête par via l'Arduino (la dernière étant de le faire via mon
téléphone Android).</p>
<blockquote>
Je dis merci à <cite>&#64;jblb_72</cite> pour son coup de main.</blockquote>
<div class="section" id="dmx">
<h2>DMX ?</h2>
<div class="section" id="dafuq-iz-dat">
<h3>Dafuq iz dat ?</h3>
<p>DMX (DMX512 en fait) signifie <em>Digital MultipleX 512</em>. C'est un standard de communication pour le contrôle d'équipements
scéniques.
Il est à ce titre utilisé pour contrôler des projecteurs et autres effets lors de concerts (ça tombe bien, c'est ce que
l'on veut faire, au concert près).</p>
<p>Le DMX repose sur les mêmes bases physiques que la RS485 et les drivers pour ce standard peuvent aussi servir pour du
DMX.</p>
<p>Notez que le DMX est habituellement utilisé via une transmission filaire à 5 points (dont sont deux peu voire pas
utilisés) ou 3 points.</p>
<p>Plus récemment, on a vu des signaux DMX passer par des cables RJ-45 (ethernet) voire carrément sans fil (voir le projet
<a class="reference external" href="http://www.goddarddesign.com/wspread.html">DMX WithOut Wire</a> ou bien même <a class="reference external" href="http://en.wikipedia.org/wiki/Art-Net">Art-Net</a>).
De mon point de vue, le transfert sans fil de trames DMX est un simple problème d'encapsulation. Si certains pensent que
j'ai tort, qu'il me le disent : j'apprendrais un truc \o/ !</p>
<p>Le DMX fonctionne par trames de 512 canaux (1 octet par canal) à une fréquence de 44Hz.
Concrètement, ça signifie que 44 fois par seconde, une trame est envoyée, contenant l'information de chacun des 512
canaux d'un octet (de <tt class="docutils literal">0x00</tt> à <tt class="docutils literal">0xFF</tt>).</p>
<p>Le rôle du maître (<em>master</em>) est d'envoyer les trames.</p>
<p>Le DMX n'est pas full-duplex, les transmissions se font d'un maître vers plusieurs esclaves et jamais d'esclave à
esclave ou d'esclave à maître.</p>
</div>
<div class="section" id="slaves">
<h3>Slaves !</h3>
<p>Les esclaves maintenant (mouhahaha !).</p>
<p>Chacun des esclaves dispose de deux informations :</p>
<ul class="simple">
<li>son adresse (de 1 à 512) configurable</li>
<li>le nombre fixe de canaux dont il a besoin</li>
</ul>
<p>Le nombre de canaux requis dépend de l'équipement, pour un gradateur simple, il suffit souvent d'un canal.
Pour une lyre, on est à 6 ou 8 canaux, pour mon PAR Led, il en faut 6 :</p>
<ul class="simple">
<li>3 pour les couleurs (RGB)</li>
<li>1 pour le mode macro</li>
<li>1 pour la vitesse du strob</li>
<li>1 pour les modes et effets</li>
</ul>
<p>L'adresse est modifiable par l'opérateur, souvent via un dip switch situé sur le récepteur (arrière du projo ou base
pour une lyre).</p>
<p>Ce qu'il faut comprendre, c'est que chaque esclave reçoit la trame complète et qu'il ne <em>lit</em> que les <strong>n</strong> canaux dont
il a besoin, <strong>adresse incluse</strong>.</p>
</div>
</div>
<div class="section" id="le-driver">
<h2>Le driver</h2>
<div class="section" id="role-du-driver">
<h3>Rôle du driver</h3>
<p>Dans les applications de communication, le <em>&quot;driver&quot;</em> est l'élément faisant le lien entre les systèmes communicants et
la liaison physique elle même.</p>
<p>Dans le cas particulier du DMX, il faut savoir que la liaison (physique) est symétrique.
C'est à dire que l'on envoie dans le lien la masse (qui sert de référence), et pour chaque fil de données on envoie
aussi l'inverse sur un second fil.
On note qu'avec un système comme celui là, le nombre minimum de brins est 3 (masse, D+, D-).</p>
<div class="section" id="pourquoi-faire-ca">
<h4>Pourquoi faire ça ?</h4>
<img alt="" class="align-right" src="/static/images/dmx/chrono.png" style="width: 400px;" />
<p>Parce que cela constitue déjà un premier moyen de réduction du bruit sur la liaison.
L'explication à ça est visible sur le schéma ci-contre.</p>
<p>Lorsqu'une interférence apparait, elle apparait sur les deux fils de data et est supprimée par la soustraction.</p>
<p>Certes, le procédé n'est pas parfait, mais il élimine déjà une bonne partie des problèmes.</p>
<p>Dans un système donné, dépendant du temps, (un Arduino par exemple), les opérations codées sont éxécutées de manière
séquentielle.
Il est ainsi compliqué de passer strictement au même instant une pin à 0 et une autre à 1 (pour produire un signal
symétrique).</p>
<p>Ainsi, le driver (externe à l'Arduino, système communicant) permet de garantie la <em>symétrie</em> du signal.
C'est d'ailleurs son rôle premier, même s'il est souvent agrémenté d'autres fonctions (souvent liées à la protection du
système de commande).</p>
</div>
</div>
<div class="section" id="un-driver-bien-fait">
<h3>Un driver bien fait</h3>
<p>Pour le DMX, le driver est souvent composé de quelques composants agencés autour d'un CI.</p>
<p>La référence revenant le plus souvent quand on parle de DMX à partir d'un arduino est certainement le <strong>MAX485</strong> de chez
<em>Maxim</em>.</p>
<p>C'est d'ailleurs la référence proposée pour le <a class="reference external" href="http://fritzing.org/projects/arduino-to-dmx-converter/">Fritzing diagram of the simplest Arduino based DMX master possible</a>.</p>
<p>Il font aussi état d'une autre référence : le 75176, normalement moins cher.</p>
<p>Bref, il faut du matériel et donc, c'est pas rigolo.</p>
</div>
<div class="section" id="un-driver-a-l-arrache">
<h3>Un driver à l'arrache</h3>
<p>Tout est parti d'un de mes tweets :</p>
<blockquote>
A votre avis, on peut recréer une trame DMX avec un alim ATX, un transistor, une resistance et un arduino ?</blockquote>
<p>Ce à quoi <a class="reference external" href="http://twitter.com/jblb_72">&#64;jblb_72</a> s'est empressé de répondre <em>&quot;2 résistances&quot;</em>.</p>
<img alt="" class="align-center" src="/static/images/dmx/driver_min.png" style="width: 600px;" />
<p>On arrive à un schéma comme celui ci-dessus.</p>
<p>Il vient violement contredire le lien mis précédement : celui ci <strong>est</strong> le driver le plus simple et minimaliste qui soit.</p>
<p>Attention toutefois, le schéma que je propose ici est potentiellement <strong>dangereux</strong> : il ne procure aucune protection
contre les boucles de masse, et aucune isolation vis a vis de l'arduino lui même.</p>
<p>Bref, il marche super bien tant qu'on s'en sert pas dans des conditions hardcore.</p>
<p>Le DMX n'a (je viens de le vérifier) aucune indication de plus que celle de la RS-485 (sur laquelle il est basé)
concernant les voltages à utiliser.
La RS-485 demande un voltage compris entre -7V et +12V, un 0 est compris lorsque la différence entre DATA+ et DATA- est
inférieure à -200mV et un 1 lorsqu'elle est supérieure à 200mV.
En fixant nos bornes à 0V et 5V, on a effectivement :</p>
<ul class="simple">
<li><tt class="docutils literal">5V - 0V &gt; 200mV</tt> =&gt; 1 reconnu</li>
<li><tt class="docutils literal">0V - 5V &lt; <span class="pre">-200mV</span></tt> =&gt; 0 reconnu</li>
</ul>
<p>Donc, contrairement à ce que dit <a class="reference external" href="http://arduino.cc/playground/DMX/DMXShield">cette page</a> on peut parfaitement utiliser un truc à l'arrache utilisant les 0V et 5V
de l'arduino sans mapper vers [-2.5V ; 2.5V] comme le fait le shield DMX présenté.</p>
<p>Enfin, vous aurez noté que j'ai utilisé un transistor 2N2222 (NPN) et des résistances de 1kOhm.
Certains diront que 100Ohms auraient suffit à saturer le transistor et à provoquer ce qu'on voulait, c'est vrai, mais
j'ai pris les premières qui venaient, donc, c'était des 1kOhm. Et tant pis.</p>
<p>Enfin, pour ce qui est de la connexion, il faut s'arranger pour mettre les fils de droite (sur le schéma) en
correspondance avec les contacts de la fiche XLR.</p>
<p>Le DMX propose de travailler avec du 5 points, mais en fait, les contacts 4 et 5 servent en théorie pour un lien de
données secondaire, ici, on en a pas besoin, donc un XLR 3 points fera très bien l'affaire (une aubaine, mon PAR est équipé de fiches 3 points).</p>
<p>Les correspondances sont les suivantes (il y des petits numéros sur les fiches XLR : 1, 2 et 3) :</p>
<ul class="simple">
<li>fil du haut (D+) =&gt; 3</li>
<li>fil du milieu (D-) =&gt; 2</li>
<li>fil du bas (masse) =&gt; 1</li>
</ul>
</div>
</div>
<div class="section" id="le-programme">
<h2>Le programme</h2>
<div class="section" id="la-lib-dmxsimple">
<h3>La lib DmxSimple</h3>
<p>A ceux qui pensaient que j'allais ré-implémenter DMX 512, désolé de vous décevoir mais c'est pas spécialement mon truc
(même si je suis sûr que ça aurait été intéressant).</p>
<p>Une lib DMX existe pour l'arduino, elle s'appelle <a class="reference external" href="http://code.google.com/p/tinkerit/wiki/DmxSimple">DmxSimple</a> et fait partie du projet <em>Tinker.it</em>.</p>
<p>On va donc se contenter d'installer la lib et de la modifier un peu pour qu'elle nous convienne.</p>
<p>Au fait, la lib DmxSimple <strong>utilise la pin 3 par défaut</strong> on va donc brancher le driver sur cette pin.</p>
<p>On commence donc par récupérer et décompresser la lib et la décompresser :</p>
<pre class="literal-block">
$ cd /tmp
$ wget http://tinkerit.googlecode.com/files/DmxSimple_v3.zip
$ unzip DmxSimple_v3.zip
</pre>
<p>Pour l'instant, la lib est dans <tt class="docutils literal">/tmp/DmxSimple/</tt>, on va maintenant éditer le fichier <tt class="docutils literal">/tmp/DmxSimple/DmxSimple.cpp</tt>
pour remplacer la ligne 11 :</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;wiring.h&quot;</span><span class="cp"></span>
</pre></div>
<p>par :</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Arduino.h&quot;</span><span class="cp"></span>
</pre></div>
<p>En effet, la lib <tt class="docutils literal">wiring.h</tt> a été remplacée par <tt class="docutils literal">Arduino.h</tt> depuis Arduino 1.0.0.</p>
<p>Reste à &quot;installer&quot; la lib via un simple :</p>
<pre class="literal-block">
$ sudo cp -r DmxSimple /usr/share/arduino/libraries/
</pre>
</div>
<div class="section" id="un-script-simple-sur-3-couleurs">
<h3>Un script simple sur 3 couleurs</h3>
<p>Pour commencer, on va juste écrire un petit programme simple : on envoie un cycle rouge-vert-bleu en boucle.</p>
<div class="highlight"><pre><span></span><span class="c1">// Inclusion de la lib DmxSimple</span>
<span class="cp">#include</span> <span class="cpf">&lt;DmxSimple.h&gt;</span><span class="cp"></span>

<span class="c1">// La fonction setup est obligatoire</span>
<span class="c1">// On la définie mais on la laisse vide :</span>
<span class="c1">// on en a pas besoin.</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// La classique loop</span>
<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// On défini un tableau sur lequel on va boucler.</span>
    <span class="c1">// Une couleur = un sous-tableau de 6 octets contenant</span>
    <span class="c1">// chacun la valeur d&#39;un des 6 canaux requis par le projecteur.</span>
    <span class="c1">// Les 3 derniers sont nul car inutiles ici.</span>
    <span class="c1">// Les 3 premiers sont respecivement Rouge, Vert et Bleu</span>
    <span class="kt">int</span> <span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// variables d&#39;itération</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// pour chaque couleur...</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// on envoie tour a tour le canal correspondant</span>
            <span class="c1">// DmxSimple.write(canal, donnée);</span>
            <span class="n">DmxSimple</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="c1">// on attend un peu avant de passer à la suite.</span>
        <span class="n">delay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Il n'y a rien de compliqué et si vous testez, vous verrez que ça marche.
C'est le programme qui est utilisé sur <a class="reference external" href="http://www.youtube.com/watch?v=Briwa3AT9fg">cette vidéo</a>.</p>
</div>
<div class="section" id="un-changement-plus-soft">
<h3>Un changement plus soft</h3>
<p>On peut aussi essayer d'imposer une forme de <em>gradient</em> en allant par exemple de <tt class="docutils literal">#FF0000</tt> (rouge) à <tt class="docutils literal">#FFFF00</tt>
(jaune).</p>
<p>Pour cela, on peut utiliser un programme comme celui ci :</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;DmxSimple.h&gt;</span><span class="cp"></span>

<span class="c1">// valeur min pour le second byte</span>
<span class="cp">#define MIN 0x00</span>
<span class="c1">// valeur max pour le second byte</span>
<span class="cp">#define MAX 0xFF</span>
<span class="c1">// temps entre chaque modif de couleur</span>
<span class="cp">#define DELAY 100</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// cette fois, on initialise notre pojecteur en rouge</span>
    <span class="kt">int</span> <span class="n">colors</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">DmxSimple</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// On envoie ensuite juste le second byte</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// on fait monter i de 1 en 1 de MIN à MAX</span>
        <span class="c1">// et on écrit la donnée</span>
        <span class="n">DmxSimple</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">delay</span><span class="p">(</span><span class="n">DELAY</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">MIN</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// et maintenant, dans l&#39;autre sens</span>
        <span class="n">DmxSimple</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">i</span><span class="o">--</span><span class="p">;</span>
        <span class="n">delay</span><span class="p">(</span><span class="n">DELAY</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Toujours rien de violent hein ! On se contente de deux boucles pour créer une impression de va et vient.</p>
</div>
</div>
<div class="section" id="et-maintenant">
<h2>Et maintenant</h2>
<p>On arrive presque à la fin de cet article et on sait désormais fabriquer à l'arrache un driver DMX et l'utiliser via
l'arduino.
C'est plutot une bonne chose.</p>
<div class="section" id="interface-python">
<h3>Interface python ?</h3>
<p>On pourrait envisager pour la suite de se servir de l'arduino comme un simple intermédiaire que l'on commanderait via la
liaison série depuis un programme python par exemple (une belle interface graphique ;)).</p>
</div>
<div class="section" id="android">
<h3>Android</h3>
<p>On peut aussi essayer de relier l'Arduino à un téléphone type Android (ou iOS, mais Android c'est mieux ;)&lt;/troll&gt;).
L'idéal serait de le faire en Bluetooth ou Wifi (via un Ethernet Shield + PoE).</p>
<p>A tester...</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Finalement, il n'y avait pas de grosse difficulté même si on a un peu cheaté en trouvant une lib sur Internet.</p>
<p>La ré-implémentation de DMX 512 est un challenge qui pourrait être intéressant et je pense que je finirais par m'y mettre.</p>
<p>Maintenant, je vais jouer avec la loupiotte !</p>
<p><strong>EDIT :</strong> Une <a class="reference external" href="https://pbs.twimg.com/media/A22ZEgMCcAEgvFw.jpg">petite photo</a> (à l'arrache aussi) du driver bricolé sur un domino. On retrouve en haut (de gauche à droite) :</p>
<ul class="simple">
<li>masse vers arduino</li>
<li>5V vers arduino (résistance)</li>
<li>Data vers arduino (pin 3)</li>
</ul>
<p>En bas :</p>
<ul class="simple">
<li>masse</li>
<li>D-</li>
<li>D+</li>
</ul>
</div>

	</article>
</section>
		</div>
		<div class=clear>&nbsp;</div>
		<footer>
			<p id=legal>Proudly powered by Pelican &mdash; 2017 &mdash; Mathieu (matael) Gaborit</p>
		</footer>
	</body>
</html>