<!DOCTYPE html>
<html lang="en">
	<head>
			<title>Thinking at Random</title>
		<meta charset="utf-8" />


		<meta name="tags" content="python" />
		<meta name="tags" content="arduino" />
		<meta name="tags" content="opencv" />
		<meta name="tags" content="ambilight" />
		<meta name="tags" content="imported" />

		<link rel=stylesheet/less type=text/css media=screen href="/theme/css/style.css" />
		<link rel=stylesheet type=text/css media=screen href="/theme/css/pygment.css" />
		<script src="/theme/js/less.min.js"></script>
	</head>

	<body>
		<div id=logo><div id=logo-wrapper>
			<header>
				<h1><a href="/"<span class=overbar><span class=big>t</span>hinking <span class=accent>at</span> <span class=big>r</span>andom</span></a></h1>
			</header>
			<nav>
				<ul>
					<li><a href="/">Writing</a></li>
					<li><a href="https://github.com/Matael">Github</a></li>
					<li><a href="https://matael.org">About</a></li>
				</ul>
			</nav>
		</div></div>
		<div id=page>
<section id=content>
	<header>
		<h1>Ambilight v2 : Threads Inside</h1>
		
	</header>
	<article>

	<div id=meta>
		<p class=by-line>Published by 
				<a href="/author/matael.html" class=author>matael</a>
		</p>
		<p>On <time datetime="2015-01-04T11:28:41+01:00">Sun 04 January 2015</span></p>
		<ul class=tags>
				<li><a href="/tag/python.html">python</a></li>
				<li><a href="/tag/arduino.html">arduino</a></li>
				<li><a href="/tag/opencv.html">opencv</a></li>
				<li><a href="/tag/ambilight.html">ambilight</a></li>
				<li><a href="/tag/imported.html">imported</a></li>
		</ul>
	</div>
	<div id=article_body>
		<p>Au cours d'un <a class="reference external" href="http://blog.matael.org/writing/a-first-try-at-ambilight/">précédent article</a> (en anglais), j'avais décrit une série de tests préliminaires à la fabrication d'un
système ambilight-like DIY.</p>
<p>Au cours d'un test sur une machine un peu moins puissante, on a noté (quelques bidouilleurs du <a class="reference external" href="http://haum.org">HAUM</a> et moi-même) une
certaine lenteur dans le processus.</p>
<p>L'article de la dernière fois statuait ainsi sur le résultat du dernier bout de code :</p>
<blockquote>
As you can see, the video is pretty smooth and reactive.</blockquote>
<p>C'était effectivement le cas, mais pas sur toutes les machines...</p>
<p>Le bout de code était le suivant :</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># instanciate CAM object</span>
<span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># get one image to process</span>
<span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># get total width/height</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># select number of regions</span>
<span class="n">nb</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># compute height and width of each region</span>
<span class="n">dh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nb</span><span class="p">)</span>
<span class="n">bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># 5% of total width</span>

<span class="c1"># act continuously</span>
<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>

    <span class="c1"># get one image to process</span>
    <span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># for each region</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>

        <span class="c1"># create masks</span>
        <span class="n">mask_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">mask_left</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mask_right</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># compute averages</span>
        <span class="n">val_left</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_left</span><span class="p">)</span>
        <span class="n">val_right</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_right</span><span class="p">)</span>

        <span class="c1"># draw rectangles</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="n">val_left</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">bandwidth</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="n">val_right</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># show image instead one saving it</span>
    <span class="c1"># &#39;w1 is the window reference</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s1">&#39;w1&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># wait 2ms for an Esc input and break if it comes.</span>
    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
<p>Par rapport au dernier article (pour le code n'avait été testé que sous Arch), j'ai ajouté les deux dernières lignes.
En effet, sans celles ci, l'ubuntu installé sur le netbook ne veut rien savoir et refuser d'afficher quoi que ce soit.</p>
<p>Bien, nous allons procéder ainsi :</p>
<ul class="simple">
<li>analyse du code existant pour déterminer ses points faibles (et il y en a)</li>
<li>réécriture pas à pas du code (en expliquant notament les principales bases de programmation multi-processus en python)</li>
</ul>
<div class="section" id="analyse">
<h2>Analyse</h2>
<p>Ce code a plusieurs problèmes, le premier et le plus évident (qui est pardonnable : c'est un simple <em>proof of concept</em>)
est qu'il ne contient aucune gestion des erreurs (<em>quid</em> si la caméra n'est pas trouvée par exemple ?).
Je ne m'attarderais pas beaucoup sur ce point, mais dans un projet fini, il faudrait veiller à gérer ça.</p>
<p>Si vous regardez bien, vous verrez combien la méthode est sale. L'algo fait ça ::</p>
<pre class="literal-block">
Faire toujours
    Récupérer une image

    Pour chaque i dans le nombre de &quot;régions&quot;
        Créer un masque blanc pour la zone droite
        Créer un masque blanc pour la zone gauche

        Pour chaque i dans dh
            Pour chaque j dans bandwidth
                Remplacer le point (i,j) par un 1 dans le masque droit
                Remplacer le point (i,j) par un 1 dans le masque gauche
            Fin Pour
        Fin Pour

        Calculer la moyenne à gauche
        Calculer la moyenne à droite

        Tracer le rectangle de droite
        Tracer le rectangle de gauche
    Fin Pour

Fin faire
</pre>
<p>L'oeil avertit aura bien évidement que le calcul des masques pour chaque zone pourrait être fait une et une seul fois et
ceux ci stockés une bonne fois pour toutes.</p>
<p>Il en va de même pour le calcul des zones elles même : on pourrait calculer une fois pour toute les 2 points les
délimitant et s'en resserir à chaque nouvelle image.</p>
<p>Enfin, vous noterez que seul le tracé des rectangle modifie l'image, tout le reste se contente de la lire : on devrait
pouvoir parallèliser ça.</p>
<p>L'idée est d'arriver à un truc comme ça : le programme se charge de récupérer une image, de pré-calculer les masques et
les zones. Il <em>spawn</em> ensuite une série de workers : plusieurs pour faire les moyennes de couleur des zones en parallèle
et un pour tracer les rectangles.</p>
</div>
<div class="section" id="preliminaires">
<h2>Préliminaires</h2>
<div class="section" id="cyclequeue">
<h3>CycleQueue</h3>
<p>Quand on traite avec des <em>threads</em>, il est courant d'utiliser <tt class="docutils literal">Queue.Queue()</tt> pour générer une file d'attente entre
les données fourni par un <em>thread</em> et consommées par un autre. J'ai pris la liberté d'étendre un peu cette classe
histoire de pouvoir &quot;bloquer&quot; un état de la file d'attente et de rappeller cet état. L'écriture de cette classe
augmentée est détaillée dans un <a class="reference external" href="http://blog.matael.org/writing/cyclequeue/">autre article</a>.</p>
<p>Voilà juste un exemple d'utilisation :</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="n">CycleQueue</span>

<span class="c1"># instanciation</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">CycleQueue</span><span class="p">()</span>

<span class="c1"># utilisation comme une Queue classique</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># vérrouillage de l&#39;état courant</span>
<span class="n">q</span><span class="o">.</span><span class="n">lockstate</span><span class="p">()</span>

<span class="c1"># utilisation comme une Queue classique</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="c1"># faire des trucs</span>
    <span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">)()</span>

<span class="c1"># restoration de l&#39;état verrouillé</span>
<span class="n">q</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>

<span class="c1"># etc...</span>
</pre></div>
</div>
<div class="section" id="singleton">
<h3>Singleton</h3>
<p>En programmation orienté objet, le <em>singleton</em> est un <em>design pattern</em> bien connu.
Il s'agit d'écrire une classe qui renverra toujours la même instance d'elle même.</p>
<p>Je suis pas un grand fan de réinvention de roue, <a class="reference external" href="http://stackoverflow.com/questions/42558/python-and-the-singleton-pattern">StackOverflow</a> propose une excellente manière d'implémenter ce <em>pattern</em>
en python.</p>
<p>Voilà donc le décorateur que j'ai utilisé (dans <tt class="docutils literal">utilities.py</tt>):</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A non-thread-safe helper class to ease implementing singletons.</span>
<span class="sd">    This should be used as a decorator -- not a metaclass -- to the</span>
<span class="sd">    class that should be a singleton.</span>

<span class="sd">    The decorated class can define one `__init__` function that</span>
<span class="sd">    takes only the `self` argument. Other than that, there are</span>
<span class="sd">    no restrictions that apply to the decorated class.</span>

<span class="sd">    To get the singleton instance, use the `Instance` method. Trying</span>
<span class="sd">    to use `__call__` will result in a `TypeError` being raised.</span>

<span class="sd">    Limitations: The decorated class cannot be inherited from.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorated</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span> <span class="o">=</span> <span class="n">decorated</span>

    <span class="k">def</span> <span class="nf">Instance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the singleton instance.  Upon its first call, it creates a</span>
<span class="sd">        new instance of the decorated class and calls its `__init__` method.</span>
<span class="sd">        On all subsequent calls, the already created instance is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Singletons must be accessed through `Instance()`.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="p">)</span>
</pre></div>
<p>Il suffira alors de décorer les classes que l'on veut <em>singleton</em> par <tt class="docutils literal">&#64;Singleton</tt>.
Ici, c'est la classe qui retient l'image elle même (et son double modifié) qui sera un <em>singleton</em> :</p>
<div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">IMG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Handle current image &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_image</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">new_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_image</span> <span class="o">=</span> <span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="globales">
<h2>Globales</h2>
<p>On fait souvent la guerre aux globales, mais ici, ça me permet d'avoir des appels de fonction relativement court et de
simplifier l'écriture. Voilà donc les globales :</p>
<div class="highlight"><pre><span></span><span class="c1"># instanciate CAM object</span>
<span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">image_width</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_height</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nb_points</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">dh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nb_points</span><span class="p">)</span>
<span class="n">bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># 5% of total width</span>

<span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
<div class="section" id="calcul-des-masques-et-des-zones">
<h3>Calcul des masques et des zones</h3>
<p>On va en profiter pour remplir <tt class="docutils literal">masks</tt> avec les masques en question. En fait, on va écrire une fonction qui sera
appellée dans <tt class="docutils literal">main()</tt> pour faire ça. Même si <tt class="docutils literal">masks</tt> est globale, je la passe en argument à la fonction (ainsi que
la <tt class="docutils literal">CycleQueue</tt> contenant les zones) pour rendre cette fonction plus portable.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enqueue_zones</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">masks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generate zones coordinates and masks and enqueue them</span>

<span class="sd">    tuple format :</span>
<span class="sd">        (y0, x0, y1, x1, index of masks)</span>

<span class="sd">    we have to store masks in another lists as Queue() doesn&#39;t</span>
<span class="sd">    recognize numpy arrays as valid datatypes</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_points</span><span class="p">):</span>
        <span class="c1"># generate masks</span>
        <span class="n">mask_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_height</span><span class="p">,</span><span class="n">image_width</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_height</span><span class="p">,</span><span class="n">image_width</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">mask_left</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mask_right</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">prev_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_left</span><span class="p">)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_right</span><span class="p">)</span>

        <span class="c1"># enqueue</span>
        <span class="c1">## left zone</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">prev_len</span><span class="p">))</span>
        <span class="c1">## right zone</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span> <span class="n">image_width</span><span class="o">-</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">prev_len</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
<p>Je pense que le code est assez clair (si vous pensez que ce n'est pas le cas, dites le moi en commentaire et je
tacherais de l'expliquer).</p>
<p>Nous avons désormais de quoi alimenter nos <em>workers</em>.</p>
</div>
</div>
<div class="section" id="workers">
<h2>Workers</h2>
<p>Ecrivons maintenant nos 2 <em>workers</em> :</p>
<ul class="simple">
<li>le moyennage des couleurs d'une part</li>
<li>le tracé des rectangles</li>
</ul>
<div class="section" id="pourquoi-threader-la-deuxieme-partie">
<h3>Pourquoi <em>threader</em> la deuxième partie ?</h3>
<p>Le fait de <em>threader</em> le tracé des rectangle permet de commencer à tracer avant la fin des moyennes.
Pour cela, les 2 programmes discuteront via une <tt class="docutils literal">Queue()</tt> les <em>workers</em> moyennant ajoutant les zones et couleurs
moyennes à la file que le <em>worker</em> dessinant viendra lire ensuite.</p>
<p>On veillera bien à attendre la vidange des 2 files (celle des zones, alimentant les <em>workers</em> moyennant et celle entre
moyenneurs et dessinateur) avant de changer de <em>frame</em>.</p>
</div>
<div class="section" id="rappels-sur-les-threads">
<h3>Rappels sur les threads</h3>
<p>Les deux workers hériteront de <tt class="docutils literal">threading.Thread</tt>.</p>
<p>La création d'un <em>thread</em> en python est assez simple (comparé à d'autres langages).</p>
<p>On crée une classe héritant de <tt class="docutils literal">threading.Thread</tt> et on écrit 2 méthodes au moins : <tt class="docutils literal">__init__</tt> et <tt class="docutils literal">run</tt>.</p>
<p>La première contient comme d'habitude les éléments d'initialisation et obligatoirement :</p>
<div class="highlight"><pre><span></span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
<p>Pour assurer la mise en place complète de la classe parente.</p>
<p>La seconde contient le code exécuté au sein du <em>thread</em>.</p>
<p>Un <em>thread</em> se code comme suit (ici un <em>thread</em> disant bonjour :</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">MyThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Hello, world!&quot;</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"># lancement du thread</span>

<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># attente de la fin du thread</span>

<span class="c1"># fin du programme</span>
</pre></div>
<p>Ici, nous allons utiliser des <tt class="docutils literal">Queue()</tt> pour faire discuter nos <em>threads</em>. Il faut savoir que d'autres mécanismes
existent : <em>mutex</em>, <em>semaphores</em>, <em>locks</em>, etc...</p>
<p>Pour plus d'info, vous pouvez jeter un oeil à la <a class="reference external" href="http://docs.python.org/2/library/threading.html">doc</a>.</p>
</div>
<div class="section" id="moyenneur">
<h3>Moyenneur</h3>
<p>Voilà le code de notre ami le moyenneur :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColorAverageWorker</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">out_queue</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_queue</span> <span class="o">=</span> <span class="n">out_queue</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masks</span><span class="p">[</span><span class="n">zone</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
            <span class="c1"># add a dict to out queue :</span>
            <span class="c1"># zone =&gt; zone tuple given by previous queue</span>
            <span class="c1"># color =&gt; color tuple given by cv2.mean()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_queue</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="s1">&#39;zone&#39;</span><span class="p">:</span> <span class="n">zone</span><span class="p">,</span>
                                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
<p>Rien de compliqué hein ? Normal :) tout le boulot est fait avant et les threads ne sont que des coques quasi-vides :)</p>
<p>Remarquez toutefois l'utilisation de :</p>
<div class="highlight"><pre><span></span><span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">image</span>
</pre></div>
<p>Qui renvoie bien l'attribut <tt class="docutils literal">image</tt> de l'instance unique de la classe <tt class="docutils literal">IMG</tt> qui est un <em>singleton</em>.</p>
</div>
<div class="section" id="dessinateur">
<h3>Dessinateur</h3>
<p>Deuxième <em>thread</em> à peine plus compliqué :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WorkerDraw</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">zone</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="s1">&#39;zone&#39;</span><span class="p">]</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span>
                <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">final_image</span><span class="p">,</span>
                <span class="p">(</span><span class="n">zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zone</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">zone</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">zone</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                <span class="n">color</span><span class="o">=</span><span class="n">point</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
                <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
<p>A noter que je ne crée la variable <tt class="docutils literal">zone</tt> que pour alléger l'écriture.
Notez là encore les <em>tuples</em> dans l'appel de <tt class="docutils literal">cv2.rectangle</tt>.</p>
<p>Finalement, la toute dernière chose à remarqué est que nous modifions <tt class="docutils literal"><span class="pre">IMG.Instance().final_image</span></tt> et non
<tt class="docutils literal"><span class="pre">IMG.Instance().image</span></tt>. Cela nous évite d'utiliser des verrous et simplifie un peu la gestion.</p>
</div>
</div>
<div class="section" id="la-main">
<h2>La main()</h2>
<p>Enfin, nous pouvons écrire le chef d'ochestre : la <tt class="docutils literal">main()</tt>.</p>
<p>Vous y trouverez une étrange ressemblance avec ce qui avait été écrit dans le <a class="reference external" href="http://blog.matael.org/writing/a-first-try-at-ambilight/">précédent article</a> :</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="c1"># init a CycleQueue for zones</span>
    <span class="n">zones</span> <span class="o">=</span> <span class="n">CycleQueue</span><span class="p">()</span>
    <span class="c1"># ... and a Queue for the drawer</span>
    <span class="n">out_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># enqueue zones</span>
    <span class="n">enqueue_zones</span><span class="p">(</span><span class="n">zones</span><span class="p">,</span> <span class="n">masks</span><span class="p">)</span>
    <span class="n">zones</span><span class="o">.</span><span class="n">lockstate</span><span class="p">()</span>

    <span class="c1"># set number of workers (averaging only)</span>
    <span class="n">num_workers</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># spawn workers</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ColorAverageWorker</span><span class="p">(</span><span class="n">zones</span><span class="p">,</span> <span class="n">out_queue</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># all workers :)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">WorkerDraw</span><span class="p">(</span><span class="n">out_queue</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># loop over frames</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="c1"># read frame</span>
        <span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="c1"># add it to singleton</span>
        <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">new_image</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># ensure you have the right queue</span>
        <span class="n">zones</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>

        <span class="c1"># wait both queues to be empty</span>
        <span class="n">zones</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">out_queue</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="c1"># show image and wait for a keystroke</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s1">&#39;w1&#39;</span><span class="p">,</span> <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">final_image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>Et voilà !</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>Cet article était un peu long, mais il pose plusieurs concepts :</p>
<ul class="simple">
<li>d'une part il revient sur des notions d'orienté objet</li>
<li>il présente succintement la mise en place de <em>threads</em> en python</li>
<li>il constitue un réécriture complète d'un script très crade</li>
<li>enfin, il revient sur des notions de modularité : presque tous les éléments peuvent être réécrits ou
modifiés/augmentés presque sans effort.</li>
</ul>
<p>Pour ceux qui voudraient le code complet, il est disponible <a class="reference external" href="/static/files/ambilight/code_threaded.zip">ici</a>.</p>
<p>En espérant que ça vous a montré quelque chose ;)</p>
</div>

	</article>
</section>
		</div>
		<div class=clear>&nbsp;</div>
		<footer>
			<p id=legal>Proudly powered by Pelican &mdash; 2017 &mdash; Mathieu (matael) Gaborit</p>
		</footer>
	</body>
</html>