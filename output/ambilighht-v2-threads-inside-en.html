<!DOCTYPE html>
<html lang="en">
	<head>
			<title>Thinking at Random</title>
		<meta charset="utf-8" />


		<meta name="tags" content="python" />
		<meta name="tags" content="arduino" />
		<meta name="tags" content="opencv" />
		<meta name="tags" content="ambilight" />
		<meta name="tags" content="imported" />

		<link rel=stylesheet/less type=text/css media=screen href="/theme/css/style.css" />
		<link rel=stylesheet type=text/css media=screen href="/theme/css/pygment.css" />
		<script src="/theme/js/less.min.js"></script>
	</head>

	<body>
		<div id=logo><div id=logo-wrapper>
			<header>
				<h1><a href="/"<span class=overbar><span class=big>t</span>hinking <span class=accent>at</span> <span class=big>r</span>andom</span></a></h1>
			</header>
			<nav>
				<ul>
					<li><a href="/">Writing</a></li>
					<li><a href="https://github.com/Matael">Github</a></li>
					<li><a href="https://matael.org">About</a></li>
				</ul>
			</nav>
		</div></div>
		<div id=page>
<section id=content>
	<header>
		<h1>Ambilighht v2 : Threads Inside (en)</h1>
		
	</header>
	<article>

	<div id=meta>
		<p class=by-line>Published by 
				<a href="/author/matael.html" class=author>matael</a>
		</p>
		<p>On <time datetime="2015-01-04T11:28:41+01:00">Sun 04 January 2015</span></p>
		<ul class=tags>
				<li><a href="/tag/python.html">python</a></li>
				<li><a href="/tag/arduino.html">arduino</a></li>
				<li><a href="/tag/opencv.html">opencv</a></li>
				<li><a href="/tag/ambilight.html">ambilight</a></li>
				<li><a href="/tag/imported.html">imported</a></li>
		</ul>
	</div>
	<div id=article_body>
		<p>In a <a class="reference external" href="http://blog.matael.org/writing/a-first-try-at-ambilight/">previous article</a> (english), I described a serie of preliminary tests towards building a ambilight-like system
(in the finest DIY way).</p>
<p>While testing on a less powerful machine, we noted (some hackers from <a class="reference external" href="http://haum.org">HAUM</a> and I) some kind of slowness in the process.</p>
<p>The last article was considering the following about the last piece of code :</p>
<blockquote>
As you can see, the video is pretty smooth and reactive.</blockquote>
<p>I was actually correct.... but not on every machine...</p>
<p>The related piece of code was :</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c1"># instanciate CAM object</span>
<span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># get one image to process</span>
<span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># get total width/height</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># select number of regions</span>
<span class="n">nb</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># compute height and width of each region</span>
<span class="n">dh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nb</span><span class="p">)</span>
<span class="n">bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># 5% of total width</span>

<span class="c1"># act continuously</span>
<span class="k">while</span> <span class="mi">1</span><span class="p">:</span>

    <span class="c1"># get one image to process</span>
    <span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># for each region</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>

        <span class="c1"># create masks</span>
        <span class="n">mask_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">mask_left</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mask_right</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># compute averages</span>
        <span class="n">val_left</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_left</span><span class="p">)</span>
        <span class="n">val_right</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_right</span><span class="p">)</span>

        <span class="c1"># draw rectangles</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">bandwidth</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="n">val_left</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">bandwidth</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="n">val_right</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># show image instead one saving it</span>
    <span class="c1"># &#39;w1 is the window reference</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s1">&#39;w1&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># wait 2ms for an Esc input and break if it comes.</span>
    <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
<p>The only change between this code and the one from last article (which had only been tested on ArchLinux) is that I
added the 2 last lines.
Indeed, without them, ubuntu (on my netbook) just refuse to display anything.</p>
<p>So, we'll proceed as follow :</p>
<ul class="simple">
<li>analyze existing code to find its weak points</li>
<li>rewrite the code step by step (explaining by the way the main principle of multi-threaded programming in Python)</li>
</ul>
<div class="section" id="analysis">
<h2>Analysis</h2>
<p>This code faces several problems, the first and most obvious (which is forgivable as this script is just a <em>proof of
concept</em>) is that there is abbsolutely no error handling (what happened if no camera is found ?).
I won't spend a lot of time of this aspect, but in a real finished project, you must fix this point.</p>
<p>If you read carefully, you'll notice that the processing is quite dirty. The algorithm is doing ::</p>
<pre class="literal-block">
Always Do
    Grab an image

    For each n in the number of &quot;regions&quot;
        Create a white mask for right zone
        Create a white mask for left zone

        For each i in dh
            For each j in bandwith
                Replace the point (i,j) with a 1 in right mask
                Replace the point (i,j) with a 1 in left mask
            End For
        End For

        Compute average of right zone
        Compute average of left zone

        Trace right rectangle
        Trace left rectangle
    End For
End Do
</pre>
<p>Trained reader will obviously notice that the mask calculations for each zone can be made only once and stored.</p>
<p>It could be done also for zones themselves : we could compute data for the 2 delimiting points and use it for each
iteration.</p>
<p>Finally, you'll notice that tracing the rectangles is the only action that modify the image : we could parallelize
computation of average colors.</p>
<p>The global idea it to create something like that : the main process grabs images and pre-computes masks and zonees
coordinates. Then, it spawns a serie of workers : several to average colors and only one to draw rectangles.</p>
</div>
<div class="section" id="preliminaries">
<h2>Preliminaries</h2>
<div class="section" id="cyclequeue">
<h3>CycleQueue</h3>
<p>When using threads, we often use <tt class="docutils literal">Queue.Queue()</tt> to create a waiting queue between data produced by a thread and
consummed by another. I've extended this class a bit, alllowing the programmer to store one queue state and to recall
this state. The conception of the augmented class is described in <a class="reference external" href="http://blog.matael.org/writing/cyclequeue/">another article</a> (fr).</p>
<p>Here is an use case :</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">utilities</span> <span class="kn">import</span> <span class="n">CycleQueue</span>

<span class="c1"># instanciation</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">CycleQueue</span><span class="p">()</span>

<span class="c1"># utilisation comme une Queue classique</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># vérrouillage de l&#39;état courant</span>
<span class="n">q</span><span class="o">.</span><span class="n">lockstate</span><span class="p">()</span>

<span class="c1"># utilisation comme une Queue classique</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="c1"># faire des trucs</span>
    <span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">)()</span>

<span class="c1"># restoration de l&#39;état verrouillé</span>
<span class="n">q</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>

<span class="c1"># etc...</span>
</pre></div>
</div>
<div class="section" id="singleton">
<h3>Singleton</h3>
<p>Within OOP, a <em>singleton</em> a well-known design pattern.
The concept is to build a class that will always reference the same instance of itself.</p>
<p>I'm not always willing to recreate all from <em>scratch</em>, <a class="reference external" href="http://stackoverflow.com/questions/42558/python-and-the-singleton-pattern">StackOverflow</a> proposes a excellent way of implementing this
pattern in Python.</p>
<p>Here is the decorator i used (inside <tt class="docutils literal">utilities.py</tt>):</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A non-thread-safe helper class to ease implementing singletons.</span>
<span class="sd">    This should be used as a decorator -- not a metaclass -- to the</span>
<span class="sd">    class that should be a singleton.</span>

<span class="sd">    The decorated class can define one `__init__` function that</span>
<span class="sd">    takes only the `self` argument. Other than that, there are</span>
<span class="sd">    no restrictions that apply to the decorated class.</span>

<span class="sd">    To get the singleton instance, use the `Instance` method. Trying</span>
<span class="sd">    to use `__call__` will result in a `TypeError` being raised.</span>

<span class="sd">    Limitations: The decorated class cannot be inherited from.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorated</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span> <span class="o">=</span> <span class="n">decorated</span>

    <span class="k">def</span> <span class="nf">Instance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the singleton instance.  Upon its first call, it creates a</span>
<span class="sd">        new instance of the decorated class and calls its `__init__` method.</span>
<span class="sd">        On all subsequent calls, the already created instance is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Singletons must be accessed through `Instance()`.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="p">)</span>
</pre></div>
<p>We will only need to decorate <em>singleton</em> classes with <tt class="docutils literal">&#64;Singleton</tt>.
Here, it's the class that will handle the image itself which will reference a singleton :</p>
<div class="highlight"><pre><span></span><span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">IMG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Handle current image &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_image</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">new_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_image</span> <span class="o">=</span> <span class="n">f</span>
</pre></div>
</div>
</div>
<div class="section" id="globals">
<h2>Globals</h2>
<p>Programmers often fight against global variables, but sometimes, this does allow clean and short function calls.
Here are my globals :</p>
<div class="highlight"><pre><span></span><span class="c1"># instanciate CAM object</span>
<span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">image_width</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_height</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nb_points</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">dh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">nb_points</span><span class="p">)</span>
<span class="n">bandwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># 5% of total width</span>

<span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
<div class="section" id="computation-for-masks-and-zones">
<h3>Computation for masks and zones</h3>
<p>Let's fill <tt class="docutils literal">masks</tt> with valid data. We'll write a function which will be called in <tt class="docutils literal">main()</tt> to do that. Even if
<tt class="docutils literal">masks</tt> is global, I give it to the function as an argument (along with the <tt class="docutils literal">CycleQueue</tt> instance for zones) to make
this function more portable.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enqueue_zones</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">masks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generate zones coordinates and masks and enqueue them</span>

<span class="sd">    tuple format :</span>
<span class="sd">        (y0, x0, y1, x1, index of masks)</span>

<span class="sd">    we have to store masks in another lists as Queue() doesn&#39;t</span>
<span class="sd">    recognize numpy arrays as valid datatypes</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_points</span><span class="p">):</span>
        <span class="c1"># generate masks</span>
        <span class="n">mask_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_height</span><span class="p">,</span><span class="n">image_width</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_height</span><span class="p">,</span><span class="n">image_width</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">dh</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">bandwidth</span><span class="p">):</span>
                <span class="n">mask_left</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mask_right</span><span class="p">[</span><span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="o">+</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">prev_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_left</span><span class="p">)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_right</span><span class="p">)</span>

        <span class="c1"># enqueue</span>
        <span class="c1">## left zone</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">prev_len</span><span class="p">))</span>
        <span class="c1">## right zone</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span> <span class="n">image_width</span><span class="o">-</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">dh</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">prev_len</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
<p>I think the code is clear enough (if you don't think so, just tell me and I'll explain it).</p>
<p>We now have all we need to feed our workers :)</p>
</div>
</div>
<div class="section" id="workers">
<h2>Workers</h2>
<p>Now, we'll write our two workers :</p>
<ul class="simple">
<li>color averaging on one hand</li>
<li>rectangles drawing on another hand</li>
</ul>
<div class="section" id="why-threading-rectangles-drawing-is-interesting">
<h3>Why threading rectangles drawing is interesting ?</h3>
<p>Threading the drawing worker alllow use to start drawing before the averaging ends.</p>
<p>To achieve that, the two workers pools will discuss through a <tt class="docutils literal">Queue</tt>, averaging workers adding zones and colors to
the queue the drawing worker will read later.</p>
<p>We'll have to carefully wait for the emptying of both queues before switching frame.</p>
</div>
<div class="section" id="thread-reminder">
<h3>Thread reminder</h3>
<p>Both worker types will inherit from <tt class="docutils literal">threading.Thread</tt>.</p>
<p>In Python, writing a thread is quite easy (in comparison to other langages).</p>
<p>We do create a class (inheriting from <tt class="docutils literal">threading.Thread</tt>) and write at least two methods : <tt class="docutils literal">__init__</tt> and <tt class="docutils literal">run</tt>.</p>
<p>The former contains (as usual) initialization elements and inevitably :</p>
<div class="highlight"><pre><span></span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
<p>To ensure complete setup from parent class.</p>
<p>The latter contains the executed code inside the thread.</p>
<p>A <em>hello World</em> thread is coded as :</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">class</span> <span class="nc">MyThread</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Hello, world!&quot;</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">MyThread</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"># lancement du thread</span>

<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span> <span class="c1"># attente de la fin du thread</span>

<span class="c1"># fin du programme</span>
</pre></div>
<p>Here, we'll use some <tt class="docutils literal">Queue</tt> to make our threads communicate. You must know that other mecanisms exist : mutex,
semaphores, locks, etc....</p>
<p>For further information, look at the <a class="reference external" href="http://docs.python.org/2/library/threading.html">doc</a>.</p>
</div>
<div class="section" id="averager">
<h3>Averager</h3>
<p>Here is the code for our dear averager thread :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColorAverageWorker</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">out_queue</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_queue</span> <span class="o">=</span> <span class="n">out_queue</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masks</span><span class="p">[</span><span class="n">zone</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
            <span class="c1"># add a dict to out queue :</span>
            <span class="c1"># zone =&gt; zone tuple given by previous queue</span>
            <span class="c1"># color =&gt; color tuple given by cv2.mean()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_queue</span><span class="o">.</span><span class="n">put</span><span class="p">({</span><span class="s1">&#39;zone&#39;</span><span class="p">:</span> <span class="n">zone</span><span class="p">,</span>
                                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
<p>Nothing complicated, uh ? As the greatest part of the job is precomputed, our threads are only quasi-empty workers :)</p>
<p>Notice, however, the usage of :</p>
<div class="highlight"><pre><span></span><span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">image</span>
</pre></div>
<p>This do return the <tt class="docutils literal">ìmage</tt> attribute for the unique instance of <tt class="docutils literal">IMG</tt> class (which is a singleton).</p>
</div>
<div class="section" id="drawer">
<h3>Drawer</h3>
<p>The second thread is almost as simple as the first one :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WorkerDraw</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
        <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">zone</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="s1">&#39;zone&#39;</span><span class="p">]</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span>
                <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">final_image</span><span class="p">,</span>
                <span class="p">(</span><span class="n">zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zone</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">zone</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">zone</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                <span class="n">color</span><span class="o">=</span><span class="n">point</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
                <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre></div>
<p>Here again, notice that the <tt class="docutils literal">zone</tt> variable is created only to make the code simpler.
Also notice <em>tuples</em> in thhe call foor <tt class="docutils literal">cv2.rectangle</tt>.</p>
<p>Finally, the last thing to notice is that we do modify <tt class="docutils literal"><span class="pre">ÌMG.Instance().final_image</span></tt> and not <tt class="docutils literal"><span class="pre">IMG.Instance().image</span></tt>.
It suppress the need for locks and simplify a bit the code.</p>
</div>
</div>
<div class="section" id="main">
<h2>Main</h2>
<p>Lastly, we can write our master process : the <tt class="docutils literal">main()</tt>.</p>
<p>You'll find a strange similarity with the code in the <a class="reference external" href="http://blog.matael.org/writing/a-first-try-at-ambilight/">previous article</a> :</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="c1"># init a CycleQueue for zones</span>
    <span class="n">zones</span> <span class="o">=</span> <span class="n">CycleQueue</span><span class="p">()</span>
    <span class="c1"># ... and a Queue for the drawer</span>
    <span class="n">out_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># enqueue zones</span>
    <span class="n">enqueue_zones</span><span class="p">(</span><span class="n">zones</span><span class="p">,</span> <span class="n">masks</span><span class="p">)</span>
    <span class="n">zones</span><span class="o">.</span><span class="n">lockstate</span><span class="p">()</span>

    <span class="c1"># set number of workers (averaging only)</span>
    <span class="n">num_workers</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># spawn workers</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ColorAverageWorker</span><span class="p">(</span><span class="n">zones</span><span class="p">,</span> <span class="n">out_queue</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># all workers :)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">WorkerDraw</span><span class="p">(</span><span class="n">out_queue</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># loop over frames</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="c1"># read frame</span>
        <span class="n">_</span><span class="p">,</span><span class="n">f</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="c1"># add it to singleton</span>
        <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">new_image</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># ensure you have the right queue</span>
        <span class="n">zones</span><span class="o">.</span><span class="n">reinit</span><span class="p">()</span>

        <span class="c1"># wait both queues to be empty</span>
        <span class="n">zones</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">out_queue</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="c1"># show image and wait for a keystroke</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s1">&#39;w1&#39;</span><span class="p">,</span> <span class="n">IMG</span><span class="o">.</span><span class="n">Instance</span><span class="p">()</span><span class="o">.</span><span class="n">final_image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">27</span><span class="p">:</span>
            <span class="k">break</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
<p>And voilà !</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>This article was a bit long, but reveal several concepts :</p>
<ul class="simple">
<li>first, it comes back on OOP concepts</li>
<li>it introduce succintly threading concepts</li>
<li>it's a full rewriting of a (very) dirty script</li>
<li>finally, it comes back on modulariity notions : almost all elements can we rewritten ou augmented almost without
effort.</li>
</ul>
<p>For those who want a complete code, it can be found <a class="reference external" href="/static/files/ambilight/code_threaded.zip">here</a>.</p>
<p>Hoping this would have help you :)</p>
</div>

	</article>
</section>
		</div>
		<div class=clear>&nbsp;</div>
		<footer>
			<p id=legal>Proudly powered by Pelican &mdash; 2017 &mdash; Mathieu (matael) Gaborit</p>
		</footer>
	</body>
</html>